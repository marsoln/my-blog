# Language
# 语言

Clients use the GraphQL query language to make requests to a GraphQL service.
We refer to these request sources as documents. A document may contain
operations (queries and mutations are both operations) as well as fragments, a
common unit of composition allowing for query reuse.

客户端使用GraphQL查询语言去请求GraphQL服务.我们将这些请求来源称之为文档(documents).一个文档可以包含操作(查询和变更都视作操作)和片段,一个复合的通用单元可以被查询重用.

A GraphQL document is defined as a syntactic grammar where terminal symbols are
tokens (indivisible lexical units). These tokens are defined in a lexical
grammar which matches patterns of source characters (defined by a
double-colon `::`).

一个GraphQL文档被定义为以终结符作为标记(最小词汇单元)的一种句法.这些标记被定义在一个符合源字符模式的词汇语法中(用双冒号做定义 `::`).

## Source Text
## 源文

SourceCharacter :: /[\u0009\u000A\u000D\u0020-\uFFFF]/

源字符 :: /[\u0009\u000A\u000D\u0020-\uFFFF]/

GraphQL documents are expressed as a sequence of
[Unicode](http://unicode.org/standard/standard.html) characters. However, with
few exceptions, most of GraphQL is expressed only in the original non-control
ASCII range so as to be as widely compatible with as many existing tools,
languages, and serialization formats as possible and avoid display issues in
text editors and source control.

GraphQL文档以Unicode字符序列的方式予以表述.然而,除极少数特例,大部分GraphQL仅使用ASCII范围内的字符进行表述,以完成与现存的多种工具,语言和序列化格式更好地兼容,避免在文本编辑器和源码控制里出现显示的问题.

### Unicode
### Unicode

UnicodeBOM :: "Byte Order Mark (U+FEFF)"

Unicode字节序标记 :: "Byte Order Mark (U+FEFF)"

Non-ASCII Unicode characters may freely appear within {StringValue} and
{Comment} portions of GraphQL.

非ASCII的Unicode字符可以用在GraphQL的字符串值和注释部分.

The "Byte Order Mark" is a special Unicode character which
may appear at the beginning of a file containing Unicode which programs may use
to determine the fact that the text stream is Unicode, what endianness the text
stream is in, and which of several Unicode encodings to interpret.

BOM是一个特殊的Unicode字符,其出现在包含Unicode字符的文件头部,程序可以以此来判断文本流是否为Unicode,文本流所处的字节顺序以及用那种Unicode编码格式进行翻译.


### White Space
### 空白字符

WhiteSpace ::
  - "Horizontal Tab (U+0009)"
  - "Space (U+0020)"

空白字符 ::
  - "水平制表符 Tab (U+0009)"
  - "空格 (U+0020)"

White space is used to improve legibility of source text and act as separation
between tokens, and any amount of white space may appear before or after any
token. White space between tokens is not significant to the semantic meaning of
a GraphQL query document, however white space characters may appear within a
{String} or {Comment} token.

空白符可用作提升源文件的可读性,标记间的分隔符,在一个标记前后都可以插入任意数量的空白符.在一个GraphQL查询文档中两个标记间的空白符没有实际语法意义,然而空白字符还可以存在于一个字符串或注释标记中.

Note: GraphQL intentionally does not consider Unicode "Zs" category characters
as white-space, avoiding misinterpretation by text editors and source
control tools.

注:GraphQL有意地不把Unicode "Zs" 类型字符视作空白字符,避免被文本编辑器和源码控制工具错译.

### Line Terminators
### 行终止符

LineTerminator ::
  - "New Line (U+000A)"
  - "Carriage Return (U+000D)" [ lookahead ! "New Line (U+000A)" ]
  - "Carriage Return (U+000D)" "New Line (U+000A)"

Like white space, line terminators are used to improve the legibility of source
text, any amount may appear before or after any other token and have no
significance to the semantic meaning of a GraphQL query document. Line
terminators are not found within any other token.

与空白符类似,行终止符用来提升源码的可读性,在一个GraphQL查询文档中任何标记前后出现的任何数量的行终止符都没有实际语法意义.行终止符不被任何其他标记所包含.

Note: Any error reporting which provide the line number in the source of the
offending syntax should use the preceding amount of {LineTerminator} to produce
the line number.

注:任何想要提供错误语法所在行的行号的错误报告都可以用其前面出现的行终止符的数量去计算.


### Comments

Comment :: `#` CommentChar*
注释 :: `#` 注释符*

CommentChar :: SourceCharacter but not LineTerminator
注释字符 :: 除了行终止符以外所有源字符

GraphQL source documents may contain single-line comments, starting with the
{`#`} marker.

GraphQL源文档可能包括单行注释,以`#`号开始.

A comment can contain any Unicode code point except {LineTerminator} so a
comment always consists of all code points starting with the {`#`} character up
to but not including the line terminator.

一个注释可以包含任意(除行终止符)Unicode字符,一个注释包含了从`#`开头到(不包括)行终止符之间所有内容.

Comments behave like white space and may appear after any token, or before a
line terminator, and have no significance to the semantic meaning of a GraphQL
query document.

注释的运作类似空白符,可以在任何标记后或者是一个行终止符前出现,且对GraphQL查询文档没有实际语法意义.

### Insignificant Commas
### 逗号

Comma :: ,

Similar to white space and line terminators, commas ({`,`}) are used to improve
the legibility of source text and separate lexical tokens but are otherwise
syntactically and semantically insignificant within GraphQL query documents.

类似空白符和行终止符,逗号被用作于提升源文件的可读性,分割词汇,然而它在GraphQL查询文档中没有语法意义.

Non-significant comma characters ensure that the absence or presence of a comma
does not meaningfully alter the interpreted syntax of the document, as this can
be a common user-error in other languages. It also allows for the stylistic use
of either trailing commas or line-terminators as list delimiters which are both
often desired for legibility and maintainability of source code.

次要的逗号字符确保自身的出现不会导致文档的译意被改变,这是其他语言中一个普遍的错误用法.它在格式上允许使用行尾逗号或者行终止符作为列举的定界符,渴望源代码既拥有易读性又拥有可维护性.

### Lexical Tokens
### 词汇标记

Token ::
  - Punctuator
  - Name
  - IntValue
  - FloatValue
  - StringValue

Token ::
  - 附加标点
  - 名称
  - 整型值
  - 浮点值
  - 字符串


A GraphQL document is comprised of several kinds of indivisible lexical tokens
defined here in a lexical grammar by patterns of source Unicode characters.

一个GraphQL文档由几种在这里以Unicode源字符形式定义的词汇语法所定义的不可分割的词汇标记所组成.

Tokens are later used as terminal symbols in a GraphQL query document syntactic
grammars.

Token之后会在一个GraphQL查询文档中作为终止符号使用.


### Ignored Tokens
### 忽略的标记

Ignored ::
  - UnicodeBOM
  - WhiteSpace
  - LineTerminator
  - Comment
  - Comma

忽略的 ::
  - BOM
  - 空白符
  - 行终止符
  - 注释
  - 逗号

Before and after every lexical token may be any amount of ignored tokens
including {WhiteSpace} and {Comment}. No ignored regions of a source
document are significant, however ignored source characters may appear within
a lexical token in a significant way, for example a {String} may contain white
space characters.

在每个词汇标记前后都可以有任意数量的空白符和注释.一个文档源文件中没有被忽略的部分都是有意义的,然而被忽略的源字符可能出现在一个词汇标记中使之具有意义,比如一个字符串中包含的空白字符.

No characters are ignored while parsing a given token, as an example no
white space characters are permitted between the characters defining a
{FloatValue}.

在解析一个指定的标记时不会忽略字符,比如定义一个浮点值的时候不允许空白字符出现在其中.


### Punctuators
### 附加标点

Punctuator :: one of ! $ ( ) ... : = @ [ ] { }

附加标点 :: ! $ () ... : = @ [ ] { } 其中之一

GraphQL documents include punctuation in order to describe structure. GraphQL
is a data description language and not a programming language, therefore GraphQL
lacks the <strike>punctionation</strike> <font style="color:red">punctuation</font> often used to describe mathematical expressions.

GraphQL文档包含附加标点以描述结构.GraphQL是一个数据描述语言,而不是一个编程语言,因此GraphQL缺乏描述数学表达式的标点符号.

### Names
### 名称

Name :: /[_A-Za-z][_0-9A-Za-z]*/

名称 :: /[_A-Za-z][_0-9A-Za-z]*/

GraphQL query documents are full of named things: operations, fields, arguments,
directives, fragments, and variables. All names must follow the same
grammatical form.

GraphQL查询文档有着各种各样命名的东西: 操作,字段,参数,指令,片段还有变量.所有的命名都必须遵从同样的语法形式.

Names in GraphQL are case-sensitive. That is to say `name`, `Name`, and `NAME`
all refer to different names. Underscores are significant, which means
`other_name` and `othername` are two different names.

GraphQL中的名称是大小写敏感的.也就是说`name`和`Name`以及`NAME`指的是不同的名称.下划线也是具有意义的,就意味着`other_name`和`othername`是两个不同的名称.

Names in GraphQL are limited to this <acronym>ASCII</acronym> subset of possible
characters to support interoperation with as many other systems as possible.

GraphQL中的名称受限于<acronym>ASCII</acronym>子集所允许的字符,目的是与其他系统能尽可能的具有互操作性.


## Query Document
## 查询文档

Document : Definition+

一个文档由至少一个定义组成

Definition :
  - OperationDefinition
  - FragmentDefinition

定义：
  - 操作定义
  - 片段定义

A GraphQL query document describes a complete file or request string received by
a GraphQL service. A document contains multiple definitions of Operations and
Fragments. GraphQL query documents are only executable by a server if they
contain an operation. However documents which do not contain operations may
still be parsed and validated to allow client to represent a single request
across many documents.

GraphQL查询文档描绘了GraphQL服务所接收到的一个完整的文件或请求字符串。一个文档包含多个操作和片段的定义。GraphQL查询文档如果包含一个操作则只可以被服务器所执行。*然而如果文档没有包含操作仍然会被解析和验证去允许客户端在多个文档中重新呈递一个单一的请求。*

If a document contains only one operation, that operation may be unnamed or
represented in the shorthand form, which omits both the query keyword and
operation name. Otherwise, if a GraphQL query document contains multiple
operations, each operation must be named. When submitting a query document with
multiple operations to a GraphQL service, the name of the desired operation to
be executed must also be provided.

如果一个文档只包含了一个操作，则该操作可以是匿名的或者是一种简化格式的描述，省略掉查询关键字和操作名称。否则，一个GraphQL查询文档包含多个操作，每个操作必须都被独立命名。当提交一个含有多个操作的查询文档到GraphQL服务时，必须提供所期望执行的操作的名称。


### Operations
### 操作

OperationDefinition :
  - OperationType Name? VariableDefinitions? Directives? SelectionSet
  - SelectionSet

操作定义：
  - 操作类型 （名称） （变量定义）（指令）选项集合
  - 选项集合

OperationType : one of `query` `mutation`

操作类型：`query` `mutation`之一

There are two types of operations that GraphQL models:

  * query - a read-only fetch.
  * mutation - a write followed by a fetch.

有两种针对GraphQL模型的操作
  * query - 一个只读的拉取
  * mutation - 一个拉取后的写入

Each operation is represented by an optional operation name and a selection set.

每个操作都由一个可选的名称和操作集合所描述。

For example, this mutation operation might "like" a story and then retrieve the
new number of likes:

例如，这个mutation操作可能“like”一个故事然后取其被“like”的次数：

```
mutation {
  likeStory(storyID: 12345) {
    story {
      likeCount
    }
  }
}
```

**Query shorthand**
**简化查询**

If a document contains only one query operation, and that query defines no
variables and contains no directives, that operation may be represented in a
short-hand form which omits the query keyword and query name.

如果一个文档仅包含一个查询操作，且这个查询没有定义变量和指令，那么这个操作可以使用一种省略查询关键字和名称的简写。

For example, this unnamed query operation is written via query shorthand.

例如，下面这个通过简化方式书写的匿名查询操作。

```graphql
{
  field
}
```

Note: many examples below will use the query short-hand syntax.
注：后续许多例子可能使用这种简写语法。

### Selection Sets
### 选项集合

SelectionSet : { Selection+ }

选项集合由至少一个选中项组成

Selection :
  - Field
  - FragmentSpread
  - InlineFragment

选中项：
  - 字段
  - 延伸片段
  - 行内片段

An operation selects the set of information it needs, and will receive exactly
that information and nothing more, avoiding over-fetching and
under-fetching data.

一个操作选中其所需的信息集合，然后只会接收到这部分信息，避免了过度/不足的数据拉取。

```graphql
{
  id
  firstName
  lastName
}
```

In this query, the `id`, `firstName`, and `lastName` fields form a selection
set. Selection sets may also contain fragment references.

在这个查询中，`id` `firstName` 和 `lastName`字段组成了一个选项集合。选项集合可能还包含片段引用。

### Fields
### 字段

Field : Alias? Name Arguments? Directives? SelectionSet?

字段：（别名）名称（参数）（指令）（选项集合）

A selection set is primarily composed of fields. A field describes one discrete
piece of information available to request within a selection set.

一个选项集合主要由字段组成。一个字段描述了一个在选项集合中允许被请求的离散的信息块。

Some fields describe complex data or relationships to other data. In order to
further explore this data, a field may itself contain a selection set, allowing
for deeply nested requests. All GraphQL operations must specify their selections
down to fields which return scalar values to ensure an unambiguously
shaped response.

有些字段描述了复杂数据或是其他数据的关联关系。为了能更远地探索数据，一个字段可能自身包含一个选项集合，允许深层次嵌套请求。所有的GraphQL操作都必须指定它们的选项到具体的能够返回标量值的字段，确保一个精确合适的相应。

For example, this operation selects fields of complex data and relationships
down to scalar values.

例如，这个操作选择了复杂数据对象和关联对象的标量值的字段

```graphql
{
  me {
    id
    firstName
    lastName
    birthday {
      month
      day
    }
    friends {
      name
    }
  }
}
```

Fields in the top-level selection set of an operation often represent some
information that is globally accessible to your application and its current
viewer. Some typical examples of these top fields include references to a
current logged-in viewer, or accessing certain types of data referenced by a
unique identifier.

在一个操作的顶级选择集合中的字段往往代表着你应用全局的信息和它的当前查看对象。几个比较典型的例子就是这些顶级的字段包含着当前登录者的引用，或者是获取一个指定唯一id的确定数据类型的引用。

```graphql
# `me` could represent the currently logged in viewer.
{
  me {
    name
  }
}

# `user` represents one of many users in a graph of data, referred to by a
# unique identifier.
{
  user(id: 4) {
    name
  }
}
```


### Arguments
### 参数

Arguments : ( Argument+ )

参数：一个以上（包含一个）参数

Argument : Name : Value

参数形式 名称：值

Fields are conceptually functions which return values, and occasionally accept
arguments which alter their behavior. These arguments often map directly to
function arguments within a GraphQL server's implementation.

字段概念上就是返回值的函数，偶尔会接收一些改变其行为的参数。这些参数常直接映射到GraphQL服务器实现里的函数的参数。

In this example, we want to query a specific user (requested via the `id`
argument) and their profile picture of a specific `size`:

下面这个例子里，我们要查询一个指明的（通过`id`参数）并且其资料中的照片也指定`size`的用户。

```graphql
{
  user(id: 4) {
    id
    name
    profilePic(size: 100)
  }
}
```

Many arguments can exist for a given field:

许多参数可以为指定的字段存在

```graphql
{
  user(id: 4) {
    id
    name
    profilePic(width: 100, height: 50)
  }
}
```

**Arguments are unordered**

**参数是无须的**

Arguments may be provided in any syntactic order and maintain identical
semantic meaning.

参数可以用任意语法顺序的方式予以提供都会保持相同的语义。

These two queries are semantically identical:

如下两个查询语义一致：

```graphql
{
  picture(width: 200, height: 100)
}
```

```graphql
{
  picture(height: 100, width: 200)
}
```


### Field Alias
### 字段别名

Alias : Name :

别名形式 名称：

By default, the key in the response object will use the field name
queried. However, you can define a different name by specifying an alias.

默认情况下，响应对象中的key会使用字段名称进行查询。然而，你也可以通过指定一个别名来定义不同的名称。

In this example, we can fetch two profile pictures of different sizes and ensure
the resulting object will not have duplicate keys:

下面这个例子，我们获取两个不同尺寸的资料图片并且保证返回对象不会有重复的键值。

```graphql
{
  user(id: 4) {
    id
    name
    smallPic: profilePic(size: 64)
    bigPic: profilePic(size: 1024)
  }
}
```

Which returns the result:

将返回如下结果：

```js
{
  "user": {
    "id": 4,
    "name": "Mark Zuckerberg",
    "smallPic": "https://cdn.site.io/pic-4-64.jpg",
    "bigPic": "https://cdn.site.io/pic-4-1024.jpg"
  }
}
```

Since the top level of a query is a field, it also can be given an alias:

在查询的顶级字段中，可以这样定义别名：

```graphql
{
  zuck: user(id: 4) {
    id
    name
  }
}
```

Returns the result:

返回如下结果：

```js
{
  "zuck": {
    "id": 4,
    "name": "Mark Zuckerberg"
  }
}
```

A field's response key is its alias if an alias is provided, and it is
otherwise the field's name.

一个字段的响应key是这个字段的名称，或者是指定的别名。

### Fragments
### 片段

FragmentSpread : ... FragmentName Directives?

延伸片段： ... 片段名称 指令（可选）

FragmentDefinition : fragment FragmentName TypeCondition Directives? SelectionSet

片段定义：片段 片段名称 类型条件 指令（可选） 选项集合

FragmentName : Name but not `on`

片段名称：名称 但是不包括`on`

Fragments are the primary unit of composition in GraphQL.

片段是GraphQL里主要的组成部分

Fragments allow for the reuse of common repeated selections of fields, reducing
duplicated text in the document. Inline Fragments can be used directly within a
selection to condition upon a type condition when querying against an interface
or union.

片段允许重用公共的重复字段选项，减少文档中的重复文本。行内片段可以在查询一个接口或者联合的类型条件中直接作为一个选项使用。

For example, if we wanted to fetch some common information about mutual friends
as well as friends of some user:

例如，如果我们想获取和某个用户的共同好友的信息：

```graphql
query noFragments {
  user(id: 4) {
    friends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
    mutualFriends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
  }
}
```

The repeated fields could be extracted into a fragment and <s>composed</s> comsumed by
a parent fragment or query.

这些重复的字段可以抽取到一个片段中并由一个父级片段或查询使用。

```graphql
query withFragments {
  user(id: 4) {
    friends(first: 10) {
      ...friendFields
    }
    mutualFriends(first: 10) {
      ...friendFields
    }
  }
}

fragment friendFields on User {
  id
  name
  profilePic(size: 50)
}
```

Fragments are consumed by using the spread operator (`...`).  All fields selected
by the fragment will be added to the query field selection at the same level
as the fragment invocation. This happens through multiple levels of fragment
spreads.

查询可以使用操作符（`...`）来使用。所有在片段中选中的字段将会添加到跟片段调用同级查询字段的选项中。这在多级片段中将会传播。

For example:

比如：

```graphql
query withNestedFragments {
  user(id: 4) {
    friends(first: 10) {
      ...friendFields
    }
    mutualFriends(first: 10) {
      ...friendFields
    }
  }
}

fragment friendFields on User {
  id
  name
  ...standardProfilePic
}

fragment standardProfilePic on User {
  profilePic(size: 50)
}
```

The queries `noFragments`, `withFragments`, and `withNestedFragments` all
produce the same response object.

以上`noFragments`,`withFragments`和`withNestedFragments`都返回同样的结果。

#### Type Conditions
#### 类型条件

TypeCondition : on NamedType

类型条件：on 类型名称

Fragments must specify the type they apply to. In this example, `friendFields`
can be used in the context of querying a `User`.

片段必须指明其作用的类型.在这个例子中`friendFields`可以在查询`User`的上下文中被使用.

Fragments cannot be specified on any input value (scalar, enumeration, or input
object).

片段不能被指定到任何输入值(标量,枚举或输入对象).

Fragments can be specified on object types, interfaces, and unions.

片段可以被指定到对象类型,接口以及组合.

Selections within fragments only return values when concrete type of the object
it is operating on matches the type of the fragment.

片段中的选项


For example in this query on the Facebook data model:

```graphql
query FragmentTyping {
  profiles(handles: ["zuck", "cocacola"]) {
    handle
    ...userFragment
    ...pageFragment
  }
}

fragment userFragment on User {
  friends {
    count
  }
}

fragment pageFragment on Page {
  likers {
    count
  }
}
```

The `profiles` root field returns a list where each element could be a `Page` or a
`User`. When the object in the `profiles` result is a `User`, `friends` will be
present and `likers` will not. Conversely when the result is a `Page`, `likers`
will be present and `friends` will not.

```js
{
  "profiles" : [
    {
      "handle" : "zuck",
      "friends" : { "count" : 1234 }
    },
    {
      "handle" : "cocacola",
      "likers" : { "count" : 90234512 }
    }
  ]
}
```

#### Inline Fragments

InlineFragment : ... TypeCondition? Directives? SelectionSet

Fragments can be defined inline within a selection set. This is done to
conditionally include fields based on their runtime type. This feature of
standard fragment inclusion was demonstrated in the `query FragmentTyping`
example. We could accomplish the same thing using inline fragments.

```graphql
query inlineFragmentTyping {
  profiles(handles: ["zuck", "cocacola"]) {
    handle
    ... on User {
      friends {
        count
      }
    }
    ... on Page {
      likers {
        count
      }
    }
  }
}
```

Inline fragments may also be used to apply a directive to a group of fields.
If the TypeCondition is omitted, an inline fragment is considered to be of the
same type as the enclosing context.

```graphql
query inlineFragmentNoType($expandedInfo: Boolean) {
  user(handle: "zuck") {
    id
    name
    ... @include(if: $expandedInfo) {
      firstName
      lastName
      birthday
    }
  }
}
```


### Input Values

Value[Const] :
  - [~Const] Variable
  - IntValue
  - FloatValue
  - StringValue
  - BooleanValue
  - EnumValue
  - ListValue[?Const]
  - ObjectValue[?Const]

Field and directive arguments accept input values of various literal primitives;
input values can be scalars, enumeration values, lists, or input objects.

If not defined as constant (for example, in {DefaultValue}), input values can be
specified as a variable. List and inputs objects may also contain variables (unless defined to be constant).

#### Int Value

IntValue :: IntegerPart

IntegerPart ::
  - NegativeSign? 0
  - NegativeSign? NonZeroDigit Digit*

NegativeSign :: -

Digit :: one of 0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: Digit but not `0`

An Int number is specified without a decimal point or exponent (ex. `1`).

#### Float Value

FloatValue ::
  - IntegerPart FractionalPart
  - IntegerPart ExponentPart
  - IntegerPart FractionalPart ExponentPart

FractionalPart :: . Digit+

ExponentPart :: ExponentIndicator Sign? Digit+

ExponentIndicator :: one of `e` `E`

Sign :: one of + -

A Float number includes either a decimal point (ex. `1.0`) or an exponent
(ex. `1e50`) or both (ex. `6.0221413e23`).

#### Boolean Value

BooleanValue : one of `true` `false`

The two keywords `true` and `false` represent the two boolean values.

#### String Value

StringValue ::
  - `""`
  - `"` StringCharacter+ `"`

StringCharacter ::
  - SourceCharacter but not `"` or \ or LineTerminator
  - \u EscapedUnicode
  - \ EscapedCharacter

EscapedUnicode :: /[0-9A-Fa-f]{4}/

EscapedCharacter :: one of `"` \ `/` b f n r t

Strings are sequences of characters wrapped in double-quotes (`"`). (ex.
`"Hello World"`). White space and other otherwise-ignored characters are
significant within a string value.

Note: Unicode characters are allowed within String value literals, however
GraphQL source must not contain some ASCII control characters so escape
sequences must be used to represent these characters.

**Semantics**

StringValue :: `""`

  * Return an empty Unicode character sequence.

StringValue :: `"` StringCharacter+ `"`

  * Return the Unicode character sequence of all {StringCharacter}
    Unicode character values.

StringCharacter :: SourceCharacter but not `"` or \ or LineTerminator

  * Return the character value of {SourceCharacter}.

StringCharacter :: \u EscapedUnicode

  * Return the character value represented by the UTF16 hexidecimal
    identifier {EscapedUnicode}.

StringCharacter :: \ EscapedCharacter

  * Return the character value of {EscapedCharacter}.


#### Enum Value

EnumValue : Name but not `true`, `false` or `null`

Enum values are represented as unquoted names (ex. `MOBILE_WEB`). It is
recommended that Enum values be "all caps". Enum values are only used in
contexts where the precise enumeration type is known. Therefore it's not
necessary to supply an enumeration type name in the literal.

An enum value cannot be "null" in order to avoid confusion. GraphQL
does not supply a value literal to represent the concept {null}.

#### List Value

ListValue[Const] :
  - [ ]
  - [ Value[?Const]+ ]

Lists are ordered sequences of values wrapped in square-brackets `[ ]`. The
values of a List literal may be any value literal or variable (ex. `[1, 2, 3]`).

Commas are optional throughout GraphQL so trailing commas are allowed and repeated
commas do not represent missing values.

**Semantics**

ListValue : [ ]

  * Return a new empty list value.

ListValue : [ Value+ ]

  * Let {inputList} be a new empty list value.
  * For each {Value+}
    * Let {value} be the result of evaluating {Value}.
    * Append {value} to {inputList}.
  * Return {inputList}

#### Input Object Values

ObjectValue[Const] :
  - { }
  - { ObjectField[?Const]+ }

ObjectField[Const] : Name : Value[?Const]

Input object literal values are unordered lists of keyed input values wrapped in
curly-braces `{ }`.  The values of an object literal may be any input value
literal or variable (ex. `{ name: "Hello world", score: 1.0 }`). We refer to
literal representation of input objects as "object literals."

**Semantics**

ObjectValue : { }

  * Return a new input object value with no fields.

ObjectValue : { ObjectField+ }

  * Let {inputObject} be a new input object value with no fields.
  * For each {field} in {ObjectField+}
    * Let {name} be {Name} in {field}.
    * Let {value} be the result of evaluating {Value} in {field}.
    * Add a field to {inputObject} of name {name} containing value {value}.
  * Return {inputObject}


### Variables

Variable : $ Name

VariableDefinitions : ( VariableDefinition+ )

VariableDefinition : Variable : Type DefaultValue?

DefaultValue : = Value[Const]

A GraphQL query can be parameterized with variables, maximizing query reuse,
and avoiding costly string building in clients at runtime.

If not defined as constant (for example, in {DefaultValue}), a {Variable} can be
supplied for an input value.

Variables must be defined at the top of an operation and are in scope
throughout the execution of that operation.

In this example, we want to fetch a profile picture size based on the size
of a particular device:

```graphql
query getZuckProfile($devicePicSize: Int) {
  user(id: 4) {
    id
    name
    profilePic(size: $devicePicSize)
  }
}
```

Values for those variables are provided to a GraphQL service along with a
request so they may be substituted during execution. If providing JSON for the
variables' values, we could run this query and request profilePic of
size `60` width:

```js
{
  "devicePicSize": 60
}
```

#### Variable use within Fragments

Query variables can be used within fragments. Query variables have global scope
with a given operation, so a variable used within a fragment must be declared
in any top-level operation that transitively consumes that fragment. If
a variable is referenced in a fragment and is included by an operation that does
not define that variable, the operation cannot be executed.


### Input Types

Type :
  - NamedType
  - ListType
  - NonNullType

NamedType : Name

ListType : [ Type ]

NonNullType :
  - NamedType !
  - ListType !

GraphQL describes the types of data expected by query variables. Input types
may be lists of another input type, or a non-null variant of any other
input type.

**Semantics**

Type : Name

  * Let {name} be the string value of {Name}
  * Let {type} be the type defined in the Schema named {name}
  * {type} must not be {null}
  * Return {type}

Type : [ Type ]

  * Let {itemType} be the result of evaluating {Type}
  * Let {type} be a List type where {itemType} is the contained type.
  * Return {type}

Type : Type !

  * Let {nullableType} be the result of evaluating {Type}
  * Let {type} be a Non-Null type where {nullableType} is the contained type.
  * Return {type}


### Directives

Directives : Directive+

Directive : @ Name Arguments?

Directives provide a way to describe alternate runtime execution and type
validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution
behavior in ways field arguments will not suffice, such as conditionally
including or skipping a field. Directives provide this by describing additional information to the executor.

Directives have a name along with a list of arguments which may accept values
of any input type.

Directives can be used to describe additional information for fields, fragments,
and operations.

As future versions of GraphQL adopts new configurable execution capabilities,
they may be exposed via directives.

#### Fragment Directives

Fragments may include directives to alter their behavior. At runtime, the directives provided on a fragment spread override those described on the
definition.

For example, the following query:

```graphql
query hasConditionalFragment($condition: Boolean) {
  ...maybeFragment @include(if: $condition)
}

fragment maybeFragment on Query {
  me {
    name
  }
}
```

Will have identical runtime behavior as

```graphql
query hasConditionalFragment($condition: Boolean) {
  ...maybeFragment
}

fragment maybeFragment on Query @include(if: $condition) {
  me {
    name
  }
}
```

FragmentSpreadDirectives(fragmentSpread) :
  * Let {directives} be the set of directives on {fragmentSpread}
  * Let {fragmentDefinition} be the FragmentDefinition in the document named {fragmentSpread} refers to.
  * For each {directive} in directives on {fragmentDefinition}
    * If {directives} does not contain a directive named {directive}
      * Add {directive} into {directives}
  * Return {directives}
