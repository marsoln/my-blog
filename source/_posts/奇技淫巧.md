---
title: 奇技淫巧
date: 2016-9-28 12:26:03
tags: javascript 
---

### generator 生成i内的 fibonacci数组

    let i = 1000;
    [...(function(limit){ 
        return function* (){
            let [prev, curr] = [0,1]
            while(prev + curr < limit){
                [prev, curr] = [curr, prev + curr]
                yield curr
            }
        }
    })(i)()]

### 求反运算配合indexOf的运用

    Array.prototype.has = String.prototype.has = function(sth){
        return !!~this.indexOf(sth)
    }

    'csa'.has('a');   // true
    [1,2,3].has('1'); // false
    [1,2,3].has(3);  // true

### 不需要中间变量,交换两个值类型变量的值得装逼进阶

    let [a,b]=[1,2]
    // 普通青年
    a=a+b
    b=a-b
    a=a-b
    // 文艺青年
    a=a^b
    b=a^b
    a=a^b
    // 进阶演化
    a^=b
    b^=a
    a^=b
    -----
    b^=a^=b
    a^=b
    -----
    a=(b^=a^=b)^a
    -----
    // 究极装逼方案
    b^=a^(a=b)

为什么会这样呢?  
因为行内的赋值写法一开始就把右侧变量的值确定下来了  
也就是说 `b^=a^(a=b)`  
等价于 `b=b^a^(a=b)`  
等价于 `b=2^1^(a=2)`  
等价于 `a=2;b=2^1^2` -- `a=2;b=1`  
也就解释了 为什么`a^=b^=a^=b`是错误的   
因为其等价于`a=a^(b=b^(a=a^b))`  
`a=1^(b=2^(a=1^2))`   // a=1,b=2
`a=1^(b=2^(a=3))` // a被赋值为3,b=2   
`a=1^(b=2^3)`  // a=3,b=2  
`a=1^(b=1)`  // a=3,b被赋值为1  
`a=1^1` // a=1,b=1
`a=0` // a被赋值为0,b=1  

### 一些数组操作的技巧,效率据说会高一些

    // 譬如说
    let arr = []
    arr[arr.length] = 1 // arr.push(1)
    [1].concat(arr) // arr.unshift(1)

    // 比如将一个数组的对象转换为数值类型
    let arr1 = ['1',2,'3']
    arr1 = arr1.map(v => +v)

    // 比如函数接收一个数值或者一组数值作为参数,也有可能不传
    function(arrOrValue){
        let _arr= [].concat(arr || [])
    }

### 不动点组合子(只适合拿来装逼)

    // 用于将递归匿名函数
    let Y = f => (x => f(y => x(x)(y)))(x => f(y => x(x)(y)))
    let steamrollArray = a => Y(fl => i => i instanceof Array ? i.reduce((p, n) => p.concat(fl(n)), []) : i)(a)

通常我们可以将需要递归求值的函数存做一个变量,然后在其内部调用其本身.
但是装逼的时候,可以采用Y-combinator(fixed-point combinator)的方式去实现匿名函数递归.
参考[Fixed-point combinator](https://en.wikipedia.org/wiki/Fixed-point_combinator)
